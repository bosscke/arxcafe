<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stateless Communication</title>
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/concepts.css">
</head>
<body>
    <a href="/" class="home-btn">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 18px; height: 18px;">
            <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18" />
        </svg>
        Home
    </a>

    <div class="container">
        <h1><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 40px; height: 40px; display: inline-block; margin-right: 10px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0z" /></svg> Stateless Communication</h1>

        <div class="intro-box">
            <p><strong>Stateless communication</strong> means each request contains everything the server needs to process it, with no reliance on stored context from previous requests. The server does not remember client state between calls. This is the default model of HTTP and is crucial for scalability, horizontal load balancing, and reliability in distributed systems.</p>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M6 13.5V6.75A2.25 2.25 0 0 1 8.25 4.5h7.5A2.25 2.25 0 0 1 18 6.75v6.75m-12 0V15a6 6 0 1 0 12 0v-1.5m-12 0h12" /></svg> Stateless vs Stateful</h2>

        <div class="architecture-grid">
            <div class="arch-card">
                <h3>Stateless</h3>
                <ul class="features-list">
                    <li>Each request is self-contained</li>
                    <li>No server memory of prior requests</li>
                    <li>Easier horizontal scaling & load balancing</li>
                    <li>Fewer coupling points; simpler failover</li>
                    <li>Clients resubmit context (auth, locale, pagination)</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Stateful</h3>
                <ul class="features-list">
                    <li>Server tracks session/state per client</li>
                    <li>Requests depend on prior interactions</li>
                    <li>Harder to scale; stickiness often required</li>
                    <li>Session recovery needed on failure</li>
                    <li>Less bandwidth per request, more coupling</li>
                </ul>
            </div>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M3 6.75A2.25 2.25 0 0 1 5.25 4.5h13.5A2.25 2.25 0 0 1 21 6.75v10.5A2.25 2.25 0 0 1 18.75 19.5H5.25A2.25 2.25 0 0 1 3 17.25V6.75Z" /></svg> How HTTP Does Stateless</h2>

        <div class="flow-diagram">
            <div style="font-weight: bold; margin-bottom: 16px; color: #667eea;">Every request must carry its own context:</div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px;">
                <div class="flow-step" style="border-left-color: #667eea;">Authorization header (token)</div>
                <div class="flow-step" style="border-left-color: #13AA52;">Accept / Content-Type</div>
                <div class="flow-step" style="border-left-color: #FFA500;">Locale / preferences</div>
                <div class="flow-step" style="border-left-color: #DD0031;">Pagination params</div>
                <div class="flow-step" style="border-left-color: #8B5CF6;">Idempotency-Key</div>
                <div class="flow-step" style="border-left-color: #14B8A6;">Trace IDs (correlation)</div>
            </div>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 3h3m-6 3h6M6.75 6h10.5a2.25 2.25 0 0 1 2.25 2.25v9A2.25 2.25 0 0 1 17.25 19.5H6.75A2.25 2.25 0 0 1 4.5 17.25v-9A2.25 2.25 0 0 1 6.75 6z" /></svg> Benefits</h2>

        <div class="pros-box">
            <h3>Why teams choose stateless:</h3>
            <ul class="features-list">
                <li><strong>Scales horizontally:</strong> Any server can handle any request</li>
                <li><strong>Simpler failover:</strong> Lost node does not lose user session</li>
                <li><strong>CDN friendly:</strong> Works well with caching and proxies</li>
                <li><strong>Easier observability:</strong> Trace requests without session coupling</li>
                <li><strong>Lower operational risk:</strong> Less sticky-session configuration</li>
            </ul>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0zm-9 3.75h.008v.008H12v-.008z" /></svg> Challenges</h2>

        <div class="cons-box">
            <h3>Trade-offs to manage:</h3>
            <ul class="features-list">
                <li><strong>More data per request:</strong> Re-sending auth/context increases payload size</li>
                <li><strong>Client responsibility:</strong> Clients must retain and resend state</li>
                <li><strong>Token handling:</strong> Security of tokens/cookies is critical</li>
                <li><strong>Idempotency complexity:</strong> Replays must be safe (payments, writes)</li>
            </ul>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M6.75 7.5l4.5 9 4.5-9m-9 0 4.5-4.5 4.5 4.5m-9 0h9m-9 0L3 12l3.75-4.5m9 0L21 12l-3.75-4.5" /></svg> Handling "State" without Server Memory</h2>

        <div class="architecture-grid">
            <div class="arch-card">
                <h3>Cookies & Tokens</h3>
                <ul class="features-list">
                    <li>JWT or opaque tokens in Authorization headers</li>
                    <li>HttpOnly, Secure cookies for auth tokens</li>
                    <li>Short-lived access + refresh tokens</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Idempotency Keys</h3>
                <ul class="features-list">
                    <li>Send unique key per unsafe write (e.g., payments)</li>
                    <li>Server stores short-lived key to dedupe retries</li>
                    <li>Protects against duplicate charges on retries</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Client-Side State</h3>
                <ul class="features-list">
                    <li>LocalStorage/SessionStorage for preferences</li>
                    <li>Cache data in memory per tab/app</li>
                    <li>Re-attach context on every call</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Backend Stores</h3>
                <ul class="features-list">
                    <li>Database/cache holds durable business state</li>
                    <li>No affinity to a specific app server</li>
                    <li>Locking/optimistic concurrency for consistency</li>
                </ul>
            </div>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6v12m-7.5 0V6m7.5 0A3.75 3.75 0 0 0 8.25 6m7.5 0h3a2.25 2.25 0 0 1 2.25 2.25v7.5A2.25 2.25 0 0 1 18.75 18h-3" /></svg> Real-World Examples</h2>

        <div class="architecture-grid">
            <div class="arch-card">
                <h3>APIs</h3>
                <p>REST/GraphQL APIs where each call carries auth token, locale, pagination, filters.</p>
            </div>
            <div class="arch-card">
                <h3>CDN Caching</h3>
                <p>Static assets and cacheable GET endpoints benefit from statelessness and shared caches.</p>
            </div>
            <div class="arch-card">
                <h3>Microservices</h3>
                <p>Service-to-service calls include JWTs and trace IDs; no per-connection session state.</p>
            </div>
            <div class="arch-card">
                <h3>Serverless</h3>
                <p>Functions scale instantly; keeping them stateless avoids cold-start session issues.</p>
            </div>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z" /></svg> Best Practices</h2>

        <div class="intro-box">
            <h3>Make stateless work smoothly:</h3>
            <ul class="features-list">
                <li>Include all required context in each request (auth, locale, tenant, tracing)</li>
                <li>Use HTTPS; secure tokens in HttpOnly cookies or Authorization headers</li>
                <li>Apply idempotency keys for non-idempotent writes (POST) and retries</li>
                <li>Prefer idempotent methods (GET, PUT, DELETE) when possible</li>
                <li>Use caching headers (Cache-Control, ETag) for safe responses</li>
                <li>Enforce short token lifetimes; rotate refresh tokens</li>
                <li>Validate and limit payload sizes to avoid abuse</li>
                <li>Log with correlation IDs to trace flows without server sessions</li>
            </ul>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0zm-9 3.75h.008v.008H12v-.008z" /></svg> Common Mistakes</h2>

        <div class="cons-box">
            <h3>Avoid these pitfalls:</h3>
            <ul class="features-list">
                <li>Assuming server remembers prior requests (it should not)</li>
                <li>Relying on sticky sessions to fix scaling instead of staying stateless</li>
                <li>Missing idempotency on payment/ordering endpoints</li>
                <li>Sending tokens in query strings (leaky, cached, logged)</li>
                <li>Not expiring or rotating tokens</li>
            </ul>
        </div>

        <h2><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5" /></svg> Code Examples</h2>

        <div style="background: rgba(102, 126, 234, 0.1); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; padding: 25px; margin: 30px 0;">
            <h3>Self-contained request with idempotency:</h3>
            <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; overflow-x: auto; margin-top: 15px; border: 1px solid rgba(255, 255, 255, 0.1);">
POST /api/payments HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json
Idempotency-Key: 0f0b8c5d-0a12-4b19-9b11-1c1c9b2d8c22
X-Request-ID: 4e1c7e21-33de-4b73-9b7f-98a2f2a6aa10

{"amount":1200,"currency":"USD","orderId":"ORD-123"}
            </div>
            <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; overflow-x: auto; margin-top: 15px; border: 1px solid rgba(255, 255, 255, 0.1);">
// Node/Express handler with idempotency + tracing
app.post('/api/payments', async (req, res) => {
    const key = req.header('Idempotency-Key');
    const traceId = req.header('X-Request-ID');
    const { amount, currency, orderId } = req.body;

    const existing = await store.findByKey(key);
    if (existing) return res.status(200).json(existing);

    const result = await chargeCustomer({ amount, currency, orderId, traceId });
    await store.save(key, result);
    res.status(200).json(result);
});
            </div>
        </div>

        <div class="intro-box" style="text-align: center; margin: 60px 0 40px;">
            <p>Stateless communication keeps servers simple and scalable. By sending all necessary context with every request, you gain reliability, easier horizontal scaling, and better compatibility with caches, proxies, and modern distributed architectures.</p>
        </div>
    </div>
</body>
</html>
