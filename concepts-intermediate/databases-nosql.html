<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Databases (NoSQL)</title>
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/concepts.css">
</head>
<body class="databases-nosql-page">
    <a href="/" class="home-btn">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 18px; height: 18px;">
            <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18" />
        </svg>
        Home
    </a>

    <div class="container">
        <h1>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 40px; height: 40px; display: inline-block; margin-right: 10px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M20.25 6.375c0 2.278-3.694 4.125-8.25 4.125S3.75 8.653 3.75 6.375m16.5 0c0-2.278-3.694-4.125-8.25-4.125S3.75 4.097 3.75 6.375m16.5 0v11.25c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125V6.375m16.5 0v3.75m-16.5-3.75v3.75m16.5 0v3.75C20.25 16.153 16.556 18 12 18s-8.25-1.847-8.25-4.125v-3.75m16.5 0c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125"/></svg>
            Databases (NoSQL)
        </h1>

        <div class="intro-box">
            <p>NoSQL databases trade rigid schemas and ACID guarantees for flexible data models, horizontal scalability, and high availability. They excel at handling massive volumes, unstructured data, and distributed workloads.</p>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25H12"/></svg>
            Types of NoSQL Databases
        </h2>
        <div class="architecture-grid">
            <div class="arch-card">
                <h3>Document Store</h3>
                <p><strong>Examples:</strong> MongoDB, CouchDB, Firestore</p>
                <ul class="features-list">
                    <li>Store JSON/BSON documents; flexible schema</li>
                    <li>Query nested fields, arrays</li>
                    <li>Use for content management, catalogs, user profiles</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Key-Value Store</h3>
                <p><strong>Examples:</strong> Redis, DynamoDB, Memcached</p>
                <ul class="features-list">
                    <li>Simple get/set by key; blazing fast</li>
                    <li>Often in-memory for caching</li>
                    <li>Use for sessions, rate limiting, leaderboards</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Wide-Column Store</h3>
                <p><strong>Examples:</strong> Cassandra, HBase, ScyllaDB</p>
                <ul class="features-list">
                    <li>Columnar storage optimized for writes</li>
                    <li>Partition by row key; scale horizontally</li>
                    <li>Use for time-series, event logs, IoT data</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Graph Database</h3>
                <p><strong>Examples:</strong> Neo4j, Amazon Neptune, ArangoDB</p>
                <ul class="features-list">
                    <li>Nodes and edges; traversal queries</li>
                    <li>Efficient for relationship-heavy data</li>
                    <li>Use for social graphs, fraud detection, recommendations</li>
                </ul>
            </div>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v18m9-9H3"/></svg>
            NoSQL vs Relational
        </h2>
        <div class="architecture-grid">
            <div class="arch-card">
                <h3>Choose NoSQL when:</h3>
                <ul class="features-list">
                    <li>Schema evolves rapidly or is unpredictable</li>
                    <li>Need horizontal scale (millions of ops/sec)</li>
                    <li>Data is hierarchical/nested (documents)</li>
                    <li>Availability > strict consistency</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>Choose Relational when:</h3>
                <ul class="features-list">
                    <li>Strong consistency & ACID required</li>
                    <li>Complex JOINs and transactions</li>
                    <li>Stable, well-defined schema</li>
                    <li>Data integrity critical (payments, finance)</li>
                </ul>
            </div>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M9.75 3.104v5.714a2.25 2.25 0 0 1-.659 1.591L5 14.5M9.75 3.104c-.251.023-.501.05-.75.082m.75-.082a24.301 24.301 0 0 1 4.5 0m0 0v5.714c0 .597.237 1.17.659 1.591L19.8 15.3M14.25 3.104c.251.023.501.05.75.082M19.8 15.3l-1.57.393A9.065 9.065 0 0 1 12 16a9.065 9.065 0 0 0-6.23-.693L5 15.3m14.8 0 .94.235a2.25 2.25 0 0 1 1.723 3.214l-1.176 2.353a2.25 2.25 0 0 1-2.01 1.25h-5.552a2.25 2.25 0 0 1-2.01-1.25L10.54 18.802a2.25 2.25 0 0 1 1.723-3.214l.94-.235"/></svg>
            CAP Theorem
        </h2>
        <div class="intro-box">
            <p>Distributed systems can guarantee at most two of: <strong>Consistency</strong>, <strong>Availability</strong>, <strong>Partition Tolerance</strong>. NoSQL databases typically choose AP or CP depending on use case.</p>
        </div>
        <div class="architecture-grid">
            <div class="arch-card">
                <h3>CP (Consistency + Partition Tolerance)</h3>
                <p><strong>Examples:</strong> MongoDB (strong reads), HBase</p>
                <ul class="features-list">
                    <li>Sacrifice availability during network splits</li>
                    <li>Strong consistency guarantees</li>
                </ul>
            </div>
            <div class="arch-card">
                <h3>AP (Availability + Partition Tolerance)</h3>
                <p><strong>Examples:</strong> Cassandra, DynamoDB, Riak</p>
                <ul class="features-list">
                    <li>Always accept reads/writes</li>
                    <li>Eventual consistency; conflicts resolved later</li>
                </ul>
            </div>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"/></svg>
            Eventual Consistency
        </h2>
        <div class="pros-box">
            <h3>How it works:</h3>
            <ul class="features-list">
                <li>Writes succeed immediately on one replica</li>
                <li>Changes propagate asynchronously to others</li>
                <li>Reads may see stale data briefly</li>
                <li>Converges to consistent state given enough time</li>
            </ul>
        </div>
        <div class="cons-box">
            <h3>Trade-offs:</h3>
            <ul class="features-list">
                <li>Higher availability & lower latency</li>
                <li>Apps must tolerate stale reads</li>
                <li>Conflict resolution strategies needed (last-write-wins, CRDTs)</li>
            </ul>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5"/></svg>
            Example: MongoDB Document
        </h2>
        <div style="background: #1e1e1e; color: #d4d4d4; padding: 14px; border-radius: 10px; font-family: 'Courier New', monospace; font-size: 10px; line-height: 1.6; border: 1px solid rgba(255,255,255,0.1); white-space: pre-wrap; overflow-wrap: break-word;">
// Insert a user document
db.users.insertOne({
  _id: ObjectId("..."),
  name: "Alice",
  email: "alice@example.com",
  roles: ["admin", "user"],
  profile: {
    age: 29,
    city: "NYC"
  },
  createdAt: new Date()
});

// Query nested fields
db.users.find({ "profile.city": "NYC" });

// Update array
db.users.updateOne(
  { _id: ObjectId("...") },
  { $push: { roles: "editor" } }
);
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3v11.25A2.25 2.25 0 0 0 6 16.5h2.25M3.75 3h-1.5m1.5 0h16.5m0 0h1.5m-1.5 0v11.25A2.25 2.25 0 0 1 18 16.5h-2.25m-7.5 0h7.5m-7.5 0-1 3m8.5-3 1 3m0 0 .5 1.5m-.5-1.5h-9.5m0 0-.5 1.5M9 11.25v1.5M12 9v3.75m3-6v6"/></svg>
            Scaling Patterns
        </h2>
        <div class="architecture-grid">
            <div class="arch-card">
                <h3>Sharding</h3>
                <p>Partition data across nodes by shard key (hash or range). Each shard owns a subset of data.</p>
            </div>
            <div class="arch-card">
                <h3>Replication</h3>
                <p>Copy data to multiple replicas for redundancy. Primary-replica or peer-to-peer topologies.</p>
            </div>
            <div class="arch-card">
                <h3>Tunable Consistency</h3>
                <p>Read/write quorums: R + W > N ensures consistency; adjust per query (strong vs eventual).</p>
            </div>
            <div class="arch-card">
                <h3>Auto-sharding</h3>
                <p>Systems like DynamoDB, Cosmos DB manage partitioning automatically; you define partition key.</p>
            </div>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12c0 1.268-.63 2.39-1.593 3.068a3.745 3.745 0 0 1-1.043 3.296 3.745 3.745 0 0 1-3.296 1.043A3.745 3.745 0 0 1 12 21c-1.268 0-2.39-.63-3.068-1.593a3.746 3.746 0 0 1-3.296-1.043 3.745 3.745 0 0 1-1.043-3.296A3.745 3.745 0 0 1 3 12c0-1.268.63-2.39 1.593-3.068a3.745 3.745 0 0 1 1.043-3.296 3.746 3.746 0 0 1 3.296-1.043A3.746 3.746 0 0 1 12 3c1.268 0 2.39.63 3.068 1.593a3.746 3.746 0 0 1 3.296 1.043 3.746 3.746 0 0 1 1.043 3.296A3.745 3.745 0 0 1 21 12Z"/></svg>
            Best Practices
        </h2>
        <div class="pros-box">
            <h3>Do this:</h3>
            <ul class="features-list">
                <li>Design data model around access patterns (query-first design)</li>
                <li>Choose partition key carefully to avoid hot shards</li>
                <li>Index frequently queried fields; avoid over-indexing</li>
                <li>Use native data types (dates, ObjectIds) instead of strings</li>
                <li>Monitor replica lag and shard balance</li>
                <li>Plan for backups and disaster recovery</li>
                <li>Test failover scenarios (replica promotion, network partitions)</li>
                <li>Use connection pooling and retries with backoff</li>
            </ul>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0zm-9 3.75h.008v.008H12v-.008z"/></svg>
            Common Pitfalls
        </h2>
        <div class="cons-box">
            <h3>Avoid these:</h3>
            <ul class="features-list">
                <li>Treating NoSQL like SQL (complex JOINs don't scale; denormalize)</li>
                <li>Poor shard key causing uneven distribution (hotspots)</li>
                <li>Ignoring consistency model (assuming strong when it's eventual)</li>
                <li>Unbounded document/column growth (monitor size limits)</li>
                <li>Missing secondary indexes on query predicates</li>
                <li>Over-fetching data (use projections to limit fields)</li>
                <li>No monitoring for slow queries or high cardinality</li>
                <li>Skipping schema validation entirely (some NoSQL supports JSON schema)</li>
            </ul>
        </div>

        <h2>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 24px; height: 24px; display: inline-block; margin-right: 8px; vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" d="M20.25 14.15v4.25c0 1.094-.787 2.036-1.872 2.18-2.087.277-4.216.42-6.378.42s-4.291-.143-6.378-.42c-1.085-.144-1.872-1.086-1.872-2.18v-4.25m16.5 0a2.18 2.18 0 0 0 .75-1.661V8.706c0-1.081-.768-2.015-1.837-2.175a48.114 48.114 0 0 0-3.413-.387m4.5 8.006c-.194.165-.42.295-.673.38A23.978 23.978 0 0 1 12 15.75c-2.648 0-5.195-.429-7.577-1.22a2.016 2.016 0 0 1-.673-.38m0 0A2.18 2.18 0 0 1 3 12.489V8.706c0-1.081.768-2.015 1.837-2.175a48.111 48.111 0 0 1 3.413-.387m7.5 0V5.25A2.25 2.25 0 0 0 13.5 3h-3a2.25 2.25 0 0 0-2.25 2.25v.894m7.5 0a48.667 48.667 0 0 0-7.5 0M12 12.75h.008v.008H12v-.008Z"/></svg>
            Use Cases by Type
        </h2>
        <div class="architecture-grid">
            <div class="arch-card">
                <h3>Document (MongoDB)</h3>
                <p>E-commerce catalogs, CMS, user profiles, real-time analytics.</p>
            </div>
            <div class="arch-card">
                <h3>Key-Value (Redis)</h3>
                <p>Session store, caching, rate limiters, pub/sub messaging.</p>
            </div>
            <div class="arch-card">
                <h3>Wide-Column (Cassandra)</h3>
                <p>Time-series metrics, IoT sensor data, event logs, click streams.</p>
            </div>
            <div class="arch-card">
                <h3>Graph (Neo4j)</h3>
                <p>Social networks, knowledge graphs, fraud detection, recommendation engines.</p>
            </div>
        </div>

        <div class="intro-box" style="text-align: center; margin: 60px 0 40px;">
            <p>NoSQL databases unlock horizontal scale and schema flexibility. Choose the right type for your access patterns, embrace eventual consistency where appropriate, and design with partition keys and query patterns in mind.</p>
        </div>
    </div>
</body>
</html>
